local Animated = require("engine.animated")

--- Manages the player's animations.
--- This handler contains a state machine for all player animations and determines
--- which animation should be playing based on the player's current state (e.g.,
--- walking, jumping, climbing).
---@class AnimationHandler
---@field animation Animated The underlying animation state machine.
local AnimationHandler = {}

--- Creates a new AnimationHandler instance.
---@param player Player The player instance this handler will be attached to.
---@return AnimationHandler The new animation handler instance.
function AnimationHandler:new(player)
    local p = player
    local handler = {}
    handler.animation = Animated:new({
        idle = { images = {}, path_pattern = "assets/entities/player-idle%d.png", frames = 4, delay = 0.4 },
        walk = { images = {}, path_pattern = "assets/entities/player-walk%d.png", frames = 4, delay = 0.1 },
        jump_start = {
            images = {},
            path_pattern = "assets/entities/player-jump-start%d.png",
            frames = 2,
            delay = 0.2,
            loops = false,
            on_complete = function() handler.animation:set_state("jump_fall") end
        },
        jump_fall = { images = {}, path_pattern = "assets/entities/player-jump-start%d.png", frames = 2, delay = 0.2 },
        jump_end = {
            images = {},
            path_pattern = "assets/entities/player-jump-end%d.png",
            frames = 5,
            delay = 0.08,
            loops = false,
            on_complete = function() handler.animation:set_state("idle") end
        },
        attack = {
            images = {},
            path_pattern = "assets/entities/player-attack%d.png",
            frames = 4,
            delay = 0.05,
            loops = false,
            on_complete = function() handler.animation:set_state("idle") end
        },
        climb_idle = {
            images = { love.graphics.newImage("assets/entities/player-climbing1.png") },
            delay = 0.1,
        },
        climb = { images = {}, path_pattern = "assets/entities/player-walk%d.png", frames = 4, delay = 0.1 },
        turn_to_climb = {
            images = {},
            path_pattern = "assets/entities/player-turning%d.png",
            frames = 14,
            delay = 0.02,
            loops = false,
            on_complete = function() handler.animation:set_state("climb_idle") end
        },
        climbing = { images = {}, path_pattern = "assets/entities/player-climbing%d.png", frames = 8, delay = 0.1 },
        descending = {
            images = {},
            path_pattern = "assets/entities/player-climbing%d.png",
            frames = 8,
            delay = 0.1,
            reversed_pattern = true
        },
        turn_from_climb = {
            images = {},
            path_pattern = "assets/entities/player-turning%d.png",
            frames = 14,
            delay = 0.02,
            loops = false,
            reversed_pattern = true,
            on_complete = function() handler.animation:set_state("idle") end
        },
    })
    handler.animation:set_state("idle")

    handler.clock_hand_centers = {}
    handler.clock_hand_color = nil

    for state_name, state_data in pairs(handler.animation.states) do
        handler.clock_hand_centers[state_name] = {}
        print(state_name)
        if state_data.images_data then
            for i, imageData in ipairs(state_data.images_data) do
                local w, h = imageData:getDimensions()
                for y = 0, h - 1 do
                    for x = 0, w - 1 do
                        local r, g, b, a = imageData:getPixel(x, y)
                        if math.abs(r - 0) < 0.001
                            and math.abs(g - 2 / 255) < 0.001
                            and math.abs(b - 21 / 255) < 0.001
                        then
                            -- record the first matching pixel as the clock-hand center:
                            handler.clock_hand_centers[state_name][i] = { x = x, y = y }
                            if not handler.clock_hand_color then
                                handler.clock_hand_color = { r, g, b, a }
                            end
                            -- break out of both loops once found:
                            x = w -- force inner loop to end
                            y = h -- force outer loop to end
                            print("x: ", x, "y: ", y, ":", r, g, b)
                        end
                    end
                end
            end
        end
    end

    return setmetatable(handler, { __index = AnimationHandler })
end

--- Updates the animation state based on player actions and physics.
---@param dt number The time elapsed since the last frame (delta time).
---@param player Player The player instance.
---@param wasClimbing boolean Whether the player was climbing in the previous frame.
---@param wasOnGround boolean Whether the player was on the ground in the previous frame.
function AnimationHandler:update(dt, player, wasClimbing, wasOnGround)
    -- If rewinding, the rewind handler controls the animation frame by frame.
    -- We only update the animation timer to progress the current frame's duration,
    -- but we don't run the state-switching logic.
    if player.rewind_handler.is_rewinding then
        self.animation:update(dt)
        return
    end
    self.animation:update(dt)

    local dx = 0
    if love.keyboard.isDown("a", "left") then dx = dx - 1 end
    if love.keyboard.isDown("d", "right") then dx = dx + 1 end

    local dy = 0
    if love.keyboard.isDown("w", "up") then dy = dy - 1 end
    if love.keyboard.isDown("s", "down") then dy = dy + 1 end

    local next_anim
    local current_anim = self.animation.current_state

    -- Animation state machine logic
    if current_anim == "attack" and not self.animation.is_finished then
        next_anim = "attack"
    elseif current_anim == "turn_to_climb" and not self.animation.is_finished then
        next_anim = "turn_to_climb"
    elseif current_anim == "turn_from_climb" and not self.animation.is_finished then
        next_anim = "turn_from_climb"
    elseif player.isClimbing then
        if not wasClimbing then
            next_anim = "turn_to_climb"
        elseif dy < 0 then
            next_anim = "climbing"
        elseif dy > 0 then
            next_anim = "descending"
        else
            next_anim = "climb_idle"
        end
    elseif wasClimbing and not player.isClimbing then
        next_anim = "turn_from_climb"
    elseif not player.onGround then
        next_anim = (player.vy < 0) and "jump_start" or "jump_fall"
    elseif not wasOnGround and player.onGround then
        next_anim = "jump_end"
    else
        next_anim = (dx == 0) and "idle" or "walk"
    end

    if next_anim and next_anim ~= current_anim then
        self.animation:set_state(next_anim)
    end
end

--- Draws the player's current animation frame.
---@param x number The x-coordinate to draw at.
---@param y number The y-coordinate to draw at.
---@param direction number The direction the player is facing (1 for right, -1 for left).
---@param size number The size to draw the sprite.
function AnimationHandler:draw(x, y, direction, size)
    local ox, oy = size / 2, size / 2
    self.animation:draw(x, y, 0, direction, 1, ox, oy)
end

function AnimationHandler:get_current_clock_hand_center()
    local anim = self.animation
    if not anim.current_state then return nil end
    local state_centers = self.clock_hand_centers[anim.current_state]
    if not state_centers then return nil end
    return state_centers[anim.current_frame]
end

return AnimationHandler
